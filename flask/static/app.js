/*** Scriot to handel getting and processing data from the backend* @author Nathan Stevens* @version 1.0*/// set the root urlvar root = location.protocol + '//' + location.host;console.log("Root", root)// global Grid.js objectvar myGrid;// capture button eventsd3.selectAll("button").on("click", function() {    // Create a variable for the button selected    let button = d3.select(this);            let value = button.property("value");    console.log("Button Value:", value);        if(value == "get_estimate") {      getEstimate();    } else {      getGeneralEstimate(value);    }});// function to process the data return from bankendfunction processData(data) {  let minText = "";  let maxText = "";  let min = 10000000;  let max = 0;  let estimates = [];    size = data.Service_City.length    // create the data array  for(let i = 0; i < size; i++) {    let estimate = [];    let installer = data.Installer_Name[i];    let cost = data.Est_Cost[i];        // set the minimum and maximum values    if(cost < min) {      min = cost;      minText = installer + " ($" + cost.toLocaleString() + ")";    }        if(cost > max) {      max = cost;      maxText = installer + " ($" + cost.toLocaleString() + ")";    }        estimate[0] = data.Service_City[i];    estimate[1] = data.Installer_Name[i];    estimate[2] = data.Installation_Count[i];    estimate[3] = data.Avg_Size_AC[i];    estimate[4] = data.Avg_Cost[i];    estimate[5] = data.My_Size_AC[i];    estimate[6] = data.eCar[i];    estimate[7] = data.Est_Cost[i];        estimates.push(estimate);  }    let estimateData = {    minText: minText,    maxText: maxText,    estimates: estimates,    count: size  }      return estimateData;}// function to make the call to backend for actual prediction makingfunction sendDataForEstimate(zipcode, kwh, ecar) {  let message = ">> Zip: " + zipcode + ", Power: " + kwh + " kWh, eCar: " + ecar;    console.log("Estimate:", message);    // let user know what information as passed  d3.select("#estimate_info").text(message);    // convert to kw by deviding by 9 hours of daylight  let kw = (kwh/(30*9)).toFixed(1)    // load the data then call the function to show the returned data  let url = root + "/api/v1.0/estimate/" + zipcode + "/" + kw + "/" + ecar;    d3.json(url).then(function (data) {    console.log(data)        estimateData = processData(data);        d3.select("#lowest").text(estimateData.minText);    d3.select("#highest").text(estimateData.maxText);        // update the message    message = estimateData.count  + " Estimates " +               d3.select("#estimate_info").text();                  d3.select("#estimate_info").text(message);        // display the table with the estimates    showEstimates(estimateData.estimates);  });    // clean out the div which may contain a grid.js table  document.getElementById('gtable').innerHTML = "";  if(myGrid) {    delete myGrid;  }  }// function to update the mapfunction getEstimate() {  let zipcode = d3.select("#zip_input").property("value");  let house_sqft = d3.select("#house_option option:checked").text();  let kwh = d3.select("#kwh_option option:checked").text();  let ecar = d3.select("#solar_option option:checked").text();    if(house_sqft != 'N/A') {    let ekwh = 0.0135*parseInt(house_sqft) + 18.7;    kwh = Math.ceil(ekwh*30); // average monthly kw hours  }    sendDataForEstimate(zipcode, kwh, ecar);}// us d3 to load the difinitions from the backendfunction getGeneralEstimate(kwh) {  let ecar = d3.select("#solar_option option:checked").text();  console.log("General Estimate: ", kwh, ecar);    sendDataForEstimate('all', kwh, ecar);}// display provider information for the selected statefunction showEstimates(estimateData) {  // create the new grid.js table or update the existing one  if(!myGrid) {    let columnNames = ["City", "Installer", "Count", "Avg KW",                        "Avg Cost", "My KW", "eCar", "Estimate"];        myGrid = new gridjs.Grid({      columns: columnNames,      sort: true,      data: estimateData    }).render(document.getElementById("gtable"));  } else {    myGrid.updateConfig({      data: estimateData    }).forceRender();  }}